---
layout: post
title:  "Paper Read 4 - A Novel QP-Based Kinematic Redundancy Resolution Method With Joint Constraints Satisfaction"
date:   2023-12-21 17:14:00 +0800
tags:
- Manipulator
toc:  true
math: true


---

## **Abstract**

1. A novel redundancy resolution method based on a less common **quadratic programming (QP) approach**

2. Velocity-level IK method allows fulfilment of the joint constraints at the **position, velocity, and acceleration levels**.

3. The discretized joint state equations allow the use of **joint accelerations as decision variables** in the QP problem.

## **Introduction**

Although the **QP formulation of IK** is known—it can be **used to derive the pseudoinverse-based IK** , this paper presents an important enhancement. The scientific novelty of this work is the proposition of a **velocity-level IK method** that allows the fulfilment of the joint **acceleration constraints** together with the **velocity- and position-level constraints**. The elements of the goal function, the Hessian matrix and other necessary quantities, are formulated in the form that uses accelerations instead of the usual velocities.

## **Method**

### **Classic Method**

The task space variables x ∈ R m, joint space variables q ∈ R n
$$
\mathbf{x}=\mathbf{f}(\mathbf{q})
$$
For a full 6 degree-of-freedom task, the vector x ∈ R 6 can consist of the end effector’s position r ∈ R 3 and orientation φ ∈ R 3 (given for example by Euler angles):
$$
\mathbf{x}=\left[\begin{array}{l}
\mathbf{r} \\
\boldsymbol{\phi}
\end{array}\right]
$$

$$
\mathbf{f}(\mathbf{q})=\left[\begin{array}{l}
\mathbf{f}_{\mathbf{r}}(\mathbf{q}) \\
\mathbf{f}_\phi(\mathbf{q})
\end{array}\right]
$$

The **analytical task Jacobian matrix Ja** is computed as
$$
\mathbf{J}_a(\mathbf{q})=\frac{\partial \mathbf{f}(\mathbf{q})}{\partial \mathbf{q}}
$$

$$
\dot{\mathbf{x}}=\mathbf{J}_a \dot{\mathbf{q}},
$$

In practice, it is often more convenient to use the **geometric Jacobian J** = J(q), since it describes the relationship between the j**oint velocities q_dot and task velocites v**
$$
\mathbf{v}=\left[\begin{array}{c}
\dot{\mathbf{r}} \\
\omega
\end{array}\right]
$$

$$
\mathbf{v}=\mathbf{J} \dot{\mathbf{q}}
$$

The difference between the two is that
$$
\dot{\phi}=\frac{\partial \phi}{\partial \boldsymbol{q}} \dot{\boldsymbol{q}}=\boldsymbol{J}_\phi(\boldsymbol{q}) \dot{\boldsymbol{q}} \neq \omega
$$
For **Analytical Jacobian**, in the Cartesian coordinate system, it yields an **"angular velocity" which is the time derivative of the angle chosen to represent the end direction**, expressed as:
$$
\dot{\boldsymbol{x}}=\frac{d}{d t}([x, y, z, \phi, \theta, \psi])=\left[\frac{d \mathbf{x}}{d t}, \frac{d \mathbf{y}}{d t}, \frac{d \mathbf{z}}{d t}, \frac{d \phi}{d t}, \frac{d \theta}{d t}, \frac{d \psi}{d t}\right]
$$
For **Geometrical Jacobian**, the **"angular velocity" obtained is the velocity around the axis of rotation**, expressed as:
$$
\dot{\boldsymbol{x}}=\left[\frac{d \mathbf{x}}{d t}, \frac{d \mathbf{y}}{d t}, \frac{d \mathbf{z}}{d t}, \omega_x, \omega_y, \omega_z,\right]
$$
**angular velocity ω** can be expressed as
$$
\omega=\mathbf{T}(\phi) \dot{\boldsymbol{\phi}}
$$
where T(φ) is a transformation matrix that corresponds to the used **method of parameterization of orientation**.



**R(J)** ⊆ R m is the range space of J(q), and it contains the **end effector task velocities v** that can be generated by the joint velocities q_dot for a given configuration q

**N(J)** ⊆ R n is the null space of J(q), and it contains the **joint velocities q_dot that do not produce any task velocity**, for a given configuration q
$$
\begin{aligned}
& \operatorname{dim}(\mathcal{R}(\mathbf{J}))=\rho \\
& \operatorname{dim}(\mathcal{N}(\mathbf{J}))=n-\rho
\end{aligned}
$$
For redundant manipulators, the Jacobian J(q) is not square (because m < n),  Moore-Penrose pseudoinverse
$$
\dot{\mathbf{q}}=\mathbf{J}^{\#} \mathbf{v}
$$
In particular, the ability of the redundant manipulator to perform self motions— enabled by the existence of N(J)—might be utilized to achieve **additional objectives along the main task**, given by v. Therefore, the minimum norm solution can be expanded to the following form
$$
\dot{\mathbf{q}}=\mathbf{J}^{\#} \mathbf{v}+\dot{\mathbf{q}}^{N S}
$$
where $\dot{\mathbf{q}}^{N S} \in \mathcal{N}(\mathbf{J})$ is the **null space velocity**. In other words, $\dot{\mathbf{q}}^{N S}$ **does not affect the end effector task velocity v**, since:
$$
\mathbf{J} \dot{\mathbf{q}}^{N S}=\mathbf{0} .
$$
The **null space velocity** is expressed:
$$
\dot{\mathbf{q}}^{N S}=\mathbf{P} \dot{\mathbf{q}}^{J S},
$$
where $\dot{\mathbf{q}}^{J S}$ is an **arbitrarily chosen vector** that represents the **constraint of the additional task specified directly in the joint space**, and $\mathbf{P}$ is the matrix which projects the vector $\dot{\mathbf{q}}^{J S}$ onto the null space of the Jacobian $\mathcal{N}(\mathbf{J})$:
$$
\mathbf{P}=\mathbf{I}_n-\mathbf{J}^{\#} \mathbf{J},
$$
and $\mathbf{J P}=\mathbf{0}$.

Learn from [【IIT腿足机器人控制讲义】A6:冗余机械臂(奇异，零空间优化) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/594404266) and [Null Space 及 NSP-WBC基础 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/607573167)
$$
\dot{\mathbf{q}}=\mathbf{J}^{\#} \mathbf{v}+\left(\mathbf{I}-\mathbf{J}^{\#} \mathbf{J}\right) \dot{\mathbf{q}}^{J S}
$$
which is the solution to the inverse kinematics problem, known as the **redundancy resolution at the velocity level**.

One of the methods to **select the vector** $\dot{\mathbf{q}}^{J S}$ for the solution is to employ **the local optimization**:
$$
\dot{\mathbf{q}}^{J S}=k_H \nabla_{\mathbf{q}} H(\mathbf{q}),
$$
where H(q) is a **scalar configuration-dependent objective function**, ∇qH(q) is its **gradient** and kH is a scalar gain **coefficient**.

The ability of the redundant manipulator to avoid the collisions with obstacles in the workspace can be also utilized by adding a task defined by its Jacobian matrix and velocity vector. However, specifying multiple additional tasks alongside the main one might result in **conflicting task situations**. Therefore, a **task priority strategy** is needed to ensure that each **lower priority task is satisfied only in the null space of the higher priority tasks**.

The multiple tasks are usually defined as:
$$
\mathbf{v}^i=\mathbf{J}^i \dot{\mathbf{q}}, \quad i=1, \ldots, l,
$$
where v i ∈ R mi is the **i-th task velocity**, J i ∈ R mi×n is the **i-th task Jacobian**, l is the number of tasks, mi is the i-th task dimension. The order of task priority is decreasing, i.e., **the task i + 1 has a lower priority than the task i**.

A recursive solution:
$$
\dot{\mathbf{q}}^i=\dot{\mathbf{q}}^{i-1}+\left(\mathbf{J}^i \mathbf{P}_A^{i-1}\right)^{\#}\left(\mathbf{v}^i-\mathbf{J}^i \dot{\mathbf{q}}^{i-1}\right),
$$
for $i=1, \ldots, l$, and where $\dot{\mathbf{q}}^l$ is the **solution accounting for all the tasks**, while $\dot{\mathbf{q}}^0=\mathbf{0}$ and $\mathbf{P}_A^0=\mathbf{I}$. The matrix $\mathbf{P}_A^i$:
$$
\mathbf{P}_A^i=\mathbf{I}-\mathbf{J}_A^i{ }^{\#} \mathbf{J}_A^i=\mathbf{P}_A^{i-1}-\left(\mathbf{J}^i \mathbf{P}_A^{i-1}\right)^{\#} \mathbf{J}^i \mathbf{P}_A^{i-1}
$$
is the **projector onto the null space** of the augmented Jacobian of the first i tasks:
$$
\mathbf{J}_A^i=\left[\begin{array}{c}
\mathbf{J}^1 \\
\mathbf{J}^2 \\
\vdots \\
\mathbf{J}^i
\end{array}\right]
$$
To obtain the joint coordinates in any given moment t, the solution has to **be integrated over time** (starting from t0):
$$
\mathbf{q}(t)=\mathbf{q}\left(t_0\right)+\int_{t_0}^t \dot{\mathbf{q}}(\tau) d \tau
$$
Equations in discrete form:
$$
\mathbf{q}_{k+1}=\mathbf{q}_0+\sum_{h=0}^k \dot{\mathbf{q}}_h \Delta t \\
\mathbf{q}_{k+1}=\mathbf{q}_k+\dot{\mathbf{q}}_k \Delta t
$$
The joint velocity $\dot{\mathbf{q}}_k$ is just a discrete form:
$$
\dot{\mathbf{q}}_k=\mathbf{J}^{\#}\left(\mathbf{q}_k\right) \mathbf{v}_k+\mathbf{P}\left(\mathbf{q}_k\right) \dot{\mathbf{q}}_k^{J S},
$$
where $\dot{\mathbf{q}}_k=\dot{\mathbf{q}}\left(t_k\right), \mathbf{v}_k=\mathbf{v}\left(t_k\right), \dot{\mathbf{q}}_k^{J S}=\dot{\mathbf{q}}^{J S}\left(t_k\right)$, and $\mathbf{P}\left(\mathbf{q}_k\right)$:
$$
\mathbf{P}\left(\mathbf{q}_k\right)=\mathbf{I}-\mathbf{J}^{\#}\left(\mathbf{q}_k\right) \mathbf{J}\left(\mathbf{q}_k\right) .
$$


### **Proposed Method**

TBD
